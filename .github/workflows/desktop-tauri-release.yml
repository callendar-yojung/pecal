name: Desktop Tauri Build & Upload

on:
  push:
    tags:
      - 'v*'
  workflow_dispatch:

jobs:
  build:
    runs-on: windows-latest

    steps:
      - name: Checkout repo
        uses: actions/checkout@v4

      - name: Setup pnpm
        uses: pnpm/action-setup@v4
        with:
          version: 9.0.0

      - name: Setup Node
        uses: actions/setup-node@v4
        with:
          node-version: 20
          cache: pnpm

      - name: Install Rust
        uses: dtolnay/rust-toolchain@stable

      - name: Rust cache
        uses: swatinem/rust-cache@v2
        with:
          workspaces: './apps/desktop/src-tauri -> target'

      - name: Install dependencies
        run: pnpm install --frozen-lockfile

      - name: Setup Azure Signing
        shell: pwsh
        working-directory: apps/desktop
        run: |
          az login --service-principal -u "${{ secrets.AZURE_CLIENT_ID }}" -p "${{ secrets.AZURE_CLIENT_SECRET }}" --tenant "${{ secrets.AZURE_TENANT_ID }}"

          New-Item -ItemType Directory -Force -Path signing-tools | Out-Null
          Invoke-WebRequest -Uri "https://dist.nuget.org/win-x86-commandline/latest/nuget.exe" -OutFile "signing-tools\nuget.exe"
          & "signing-tools\nuget.exe" install Microsoft.ArtifactSigning.Client -OutputDirectory signing-tools -ExcludeVersion

          @{
            Endpoint = "https://krc.codesigning.azure.net"
            CodeSigningAccountName = "callendsigning"
            CertificateProfileName = "DesktopCalendarProfile"
            ExcludeCredentials = @(
              "ManagedIdentityCredential"
              "WorkloadIdentityCredential"
              "SharedTokenCacheCredential"
              "VisualStudioCredential"
              "VisualStudioCodeCredential"
              "AzurePowerShellCredential"
              "AzureDeveloperCliCredential"
              "InteractiveBrowserCredential"
              "EnvironmentCredential"
            )
          } | ConvertTo-Json | Set-Content "signing-tools\metadata.json"

          if (Test-Path "signing-tools\Microsoft.ArtifactSigning.Client\bin\x64\Azure.CodeSigning.Dlib.dll") {
            Write-Host "Signing dlib installed successfully"
          } else {
            Write-Error "Signing dlib not found"
            exit 1
          }

      - name: Get version from tag
        id: version
        shell: pwsh
        run: |
          $version = "${env:GITHUB_REF}" -replace '^refs/tags/v', ''
          "VERSION=$version" | Out-File -FilePath $env:GITHUB_OUTPUT -Encoding utf8 -Append

      - name: Update version in tauri.conf.json
        shell: pwsh
        working-directory: apps/desktop
        run: |
          $version = "${{ steps.version.outputs.VERSION }}"
          Write-Host "Updating version to $version"
          node scripts/update-version.mjs "$version"
          Select-String -Path src-tauri/tauri.conf.json -Pattern '"version"' | Select-Object -First 1
          Select-String -Path src-tauri/tauri.conf.json -Pattern '"signCommand"' | Select-Object -First 1

      - name: Verify signing files
        shell: pwsh
        working-directory: apps/desktop
        run: |
          if (-not (Test-Path "src-tauri/sign.ps1")) {
            Write-Error "missing src-tauri/sign.ps1"
            exit 1
          }
          if (-not (Test-Path "signing-tools/metadata.json")) {
            Write-Error "missing signing-tools/metadata.json"
            exit 1
          }
          if (-not (Test-Path "signing-tools/Microsoft.ArtifactSigning.Client/bin/x64/Azure.CodeSigning.Dlib.dll")) {
            Write-Error "missing Azure.CodeSigning.Dlib.dll"
            exit 1
          }
          Write-Host "signing prerequisites are ready"

      - name: Build Tauri app
        working-directory: apps/desktop
        shell: pwsh
        run: pnpm tauri:build:ci
        env:
          TAURI_SIGNING_PRIVATE_KEY: ${{ secrets.TAURI_SIGNING_PRIVATE_KEY }}
          TAURI_SIGNING_PRIVATE_KEY_PASSWORD: ${{ secrets.TAURI_SIGNING_PRIVATE_KEY_PASSWORD }}

      - name: Find and prepare artifacts
        id: artifacts
        shell: pwsh
        run: |
          $bundleDir = "apps/desktop/src-tauri/target/release/bundle"
          Write-Host "=== Debug: Searching for artifacts ==="
          if (Test-Path $bundleDir) {
            Get-ChildItem -Path $bundleDir -Recurse -File | ForEach-Object { $_.FullName }
          } else {
            Write-Host "No bundle directory found"
          }

          $artifact = Get-ChildItem -Path $bundleDir -Recurse -Filter *.msi -File | Select-Object -First 1
          $sigFile = Get-ChildItem -Path $bundleDir -Recurse -Filter *.msi.sig -File | Select-Object -First 1

          Write-Host "=== Found artifact: $($artifact.FullName) ==="
          Write-Host "=== Found signature: $($sigFile.FullName) ==="

          if (-not $artifact) {
            Write-Error "No MSI artifact found."
            exit 1
          }

          $artifactName = $artifact.Name
          $artifactPath = Join-Path $env:GITHUB_WORKSPACE $artifactName
          Copy-Item $artifact.FullName $artifactPath -Force

          "ARTIFACT_NAME=$artifactName" | Out-File -FilePath $env:GITHUB_OUTPUT -Encoding utf8 -Append
          "ARTIFACT_PATH=$artifactPath" | Out-File -FilePath $env:GITHUB_OUTPUT -Encoding utf8 -Append

          if ($sigFile) {
            $sigName = $sigFile.Name
            $sigPath = Join-Path $env:GITHUB_WORKSPACE $sigName
            Copy-Item $sigFile.FullName $sigPath -Force
            "SIG_NAME=$sigName" | Out-File -FilePath $env:GITHUB_OUTPUT -Encoding utf8 -Append
            "SIG_PATH=$sigPath" | Out-File -FilePath $env:GITHUB_OUTPUT -Encoding utf8 -Append
            $signature = Get-Content $sigFile.FullName -Raw
            "SIGNATURE=$signature" | Out-File -FilePath $env:GITHUB_OUTPUT -Encoding utf8 -Append
          }

          $fileSize = (Get-Item $artifactPath).Length
          $checksum = (Get-FileHash $artifactPath -Algorithm SHA256).Hash.ToLower()
          "FILE_SIZE=$fileSize" | Out-File -FilePath $env:GITHUB_OUTPUT -Encoding utf8 -Append
          "CHECKSUM=$checksum" | Out-File -FilePath $env:GITHUB_OUTPUT -Encoding utf8 -Append

      - name: Configure AWS credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          aws-region: ${{ secrets.AWS_REGION }}

      - name: Upload to S3
        id: s3_upload
        shell: pwsh
        run: |
          $version = "${{ steps.version.outputs.VERSION }}"
          $platform = "windows"
          $artifactName = "${{ steps.artifacts.outputs.ARTIFACT_NAME }}"
          $artifactPath = "${{ steps.artifacts.outputs.ARTIFACT_PATH }}"

          $s3Path = "s3://${{ secrets.AWS_S3_BUCKET }}/releases/v$version/$platform/$artifactName"
          aws s3 cp "$artifactPath" "$s3Path"

          $s3Url = "https://${{ secrets.AWS_S3_BUCKET }}.s3.${{ secrets.AWS_REGION }}.amazonaws.com/releases/v$version/$platform/$artifactName"
          "S3_URL=$s3Url" | Out-File -FilePath $env:GITHUB_OUTPUT -Encoding utf8 -Append

          $sigName = "${{ steps.artifacts.outputs.SIG_NAME }}"
          $sigPath = "${{ steps.artifacts.outputs.SIG_PATH }}"
          if ($sigName -and (Test-Path $sigPath)) {
            aws s3 cp "$sigPath" "s3://${{ secrets.AWS_S3_BUCKET }}/releases/v$version/$platform/$sigName"
          }

      - name: Save release info to database
        shell: pwsh
        continue-on-error: true
        run: |
          $payload = @{
            version = "${{ steps.version.outputs.VERSION }}"
            platform = "windows"
            fileName = "${{ steps.artifacts.outputs.ARTIFACT_NAME }}"
            downloadUrl = "${{ steps.s3_upload.outputs.S3_URL }}"
            fileSize = [int64]"${{ steps.artifacts.outputs.FILE_SIZE }}"
            checksum = "${{ steps.artifacts.outputs.CHECKSUM }}"
            signature = "${{ steps.artifacts.outputs.SIGNATURE }}"
            releaseNotes = "${{ github.event.head_commit.message }}"
            isPrerelease = $false
          } | ConvertTo-Json -Compress

          Invoke-RestMethod `
            -Method Post `
            -Uri "${{ secrets.API_BASE_URL }}/api/releases" `
            -Headers @{
              "Content-Type" = "application/json"
              "Authorization" = "Bearer ${{ secrets.API_SECRET_KEY }}"
            } `
            -Body $payload

      - name: Upload artifact for release
        uses: actions/upload-artifact@v4
        with:
          name: windows-build
          path: |
            ${{ steps.artifacts.outputs.ARTIFACT_PATH }}
            ${{ steps.artifacts.outputs.SIG_PATH }}
